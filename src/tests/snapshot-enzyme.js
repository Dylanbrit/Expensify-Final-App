// testing react components is different than testing the functions inside our generators and reducers
// in our generators and reducers we are only concerned with testing if we are getting back the correct info
// in our components we are concerned about what renders in what situation
// if i pass a prop into a component i would expect it to render one way, and if i pass a prop in with a different value i expect it to render a different way
// how are we going to virtually render our component?
// we need a way to figure out what jsx comes back, but we are not viewing it in the browser, we are accessing it via code
// we can use react-test-renderer to render our compnents inside regular JS code and then we can assert something about what got rendered
// first we have to import it
// there are two types of testing in components- shallow rendereing and full DOM rendering
// we use shallow rendering for components that dont rely on user interaction or life cycle events
// shallow rendering renders just the component we are testing
// full DOM rendering renders child components but if there are none, the test will fail
// what comes back from this when we log it is a snapshot of what our code looks like- our header with the navlinks as props
// it would be ridiculous to type all of that output out inside a expect(Header).toEqual(blahblahblah) call, since it is a bunch of outpout
// instead, we use snapshot
// snapshot allows us to track changes to data over time
// it lets us create a SNAPSHOT of our component at its current point in time, and we get notified if this ever changes
// toMatchSnapshot is provided by Jest- it is what we call to make sure everything is working with our component
// the first time we call toMatchSnapshot, it is always going to pass- since there is no snpashot, jest is going to try to create a new one
// when we run the first toMatchSnapshot test, a new folder is generated by jest inside our tests component folder
// never change anything in there!
// the second time we run it, it will then compare the component to the snapshot it made to see if it matches
// if the code does not match the second time, we will be alerted, then we can determine if we want to accept or reject the changes
// if the changes were intentional, then we can press u to accept the changes and update the snapshot
// if we check our snapshots folder and find our file that we updated, we will notice that the recorded snapshot has changed there in accordance with our update we allowed
// react-test-renderer is very simple, and in this test above we basically used all teh features
// simply put- we create a new renderer, we render something to it, and then we get the rendered output
// for our more complex components, react-test-renderer doesn't work great since there are a lot of other things we need to test
// to handle these more complex components we are going to use enzyme- a library released by airbnb
// enzyme is a full featured render for react
// we need to install enzyme
// the newest release of enzyme requires us to install a few other things that arent built into the core library
// enzyme-adapter-react-16 is the first thing we need to install
// this adapter lets us specify which version of react we want to test against
// the last module is a polyfill for a browser feature known as request-animation-frame (raf), which is provided by the browser
// once installed, we need to configure enzyme to make it work
// we need to set up a setup test file in our project that allows us to configure our test environment and set up the enzyme adapter so we only have to do it once instead of everytime we use enzyme
// the new file sits in tests and is called setupTests.js- this is a file that runs that lets us configure the environment we are running in
// we import enzyme, the adapter, and just call a single method to wire up enzyme to work with the adapter
// we call Enzyme.configure() and we only pass in an object that lets us specify various configuration properties
// adapter is pretty much the only one we use, and we set enzyme: new Adapter() to set it up
// now when we use enzyme in our test cases, it will be adding support for v16 of React
// now that we've done this, we have the library working and the environment all set up
// then we set up a jest configuration json file that allows us to specify that the setup tests file should run, since it is not in s special place where it gets run automatically
// we use setupFiles to specify an array of files, jest runs those files before running our tests, and this lets us set things up such as the setupTests.js file
// this file lives in the root of our project
// we set up a json object, and we specify the things we want to configure- for us that is just "setupFiles"- a name that comes from the docs and needs to be used specifically
// we set this equal to an array of paths to files that we want to have be our setup files
// the first one is request animation frame polyfill and the second is the JS file we just created
// "raf/polyfill" is where we grab the JS file that adds the polyfill
// "<rootDir>/src/tests/setupTests.js" is the relative path that makes sure the setup tests loads then our test suite runs
// in our package.json, we need to change our jest command to tell it where it can find our config file
// we set the test script to "jest --config=jest.config.json"
// enzyme provides us two different ways to render things
// shallow rendering 
// full dom rendering