import { shallow } from 'enzyme'
import React from 'react'
import Header from '../../components/Header'

// shallow rendering
// we use ReactShallowRenderer to render Header
// getRenderOutput returns rendered outpout of the jsx we put in

test('should render header correctly', () => {
    const wrapper = shallow(<Header />)
    expect(wrapper).toMatchSnapshot()

    // const renderer = new ReactShallowRenderer()
    // renderer.render(<Header />)
    // expect(renderer.getRenderOutput()).toMatchSnapshot()
})

// what comes back from this when we log it is a snapshot of what our code looks like- our header with the navlinks as props
// it would be ridiculous to type all of that output out inside a expect(Header).toEqual(blahblahblah) call, since it is a bunch of outpout
// instead, we use snapshot
// snapshot allows us to track changes to data over time
// it lets us create a SNAPSHOT of our component at its current point in time, and we get notified if this ever changes
// toMatchSnapshot is provided by Jest- it is what we call to make sure everything is working with our component
// the first time we call toMatchSnapshot, it is always going to pass- since there is no snpashot, jest is going to try to create a new one
// when we run the first toMatchSnapshot test, a new folder is generated by jest inside our tests component folder
// never change anything in there!
// the second time we run it, it will then compare the component to the snapshot it made to see if it matches
// if the code does not match the second time, we will be alerted, then we can determine if we want to accept or reject the changes
// if the changes were intentional, then we can press u to accept the changes and update the snapshot
// if we check our snapshots folder and find our file that we updated, we will notice that the recorded snapshot has changed there in accordance with our update we allowed
// this new snapshot is the one that will be used to compare all changes made moving forward to that component

// to use enzyme (to test more complex components) we need to import { shallow } from enzyme
// then inside our test we create a variable (usually called wrapper) and inside there we call the shallow method as a function and pass in the jsx we want to render
// now we have access to the full api in enzyme
// from here we can use expect to make an assertion about what was rendered from our jsx
// to make snapshot work with enzyme, there is a utility library we need to install- enzyme-to-json
// this lets us get our json back to give us an accurate snapshot
// the last piece of configuration we need to do is set up enzyme-to-json to work automatically
// this way we dont have to add it into our code every time
// to do this, we add the config into our jest.config.json file, right underneath setupFiles
// we just need to set up snapshotSerializers equal to an array of serializers- ours is a string value called enzyme-to-json/serializer